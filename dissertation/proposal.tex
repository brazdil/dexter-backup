%%%%%%%%%%%%%%% Updated by MR March 2007 %%%%%%%%%%%%%%%%
\documentclass[12pt]{article}
\usepackage{a4wide}
\usepackage[UKenglish]{babel}
\usepackage[UKenglish]{isodate}
\usepackage[style=footnote-dw]{biblatex}
\bibliography{memoire-bb}

\newcommand{\al}{$<$}
\newcommand{\ar}{$>$}

\parindent 0pt
\parskip 6pt

\begin{document}

\thispagestyle{empty}

\rightline{\large\emph{David Brazdil}}
\medskip
\rightline{\large\emph{Trinity Hall}}
\medskip
\rightline{\large\emph{db538}}

\vspace{0.3in}
\centerline{\large Computer Science Tripos Part II Project Proposal}
\vspace{0.4in}
\centerline{\Large\bf Taint-Based Flow Tracing by}
\vspace{0.1in}
\centerline{\Large\bf Bytecode Instrumentation on Android}
\vspace{0.3in}
\cleanlookdateon
\centerline{\large \emph \today}
\vspace{0.5in}

\section*{Introduction and Description of the Work}

Android is a popular, open-source Linux-based platform for touchscreen
mobile devices, such as smartphones and tablets. Ever since its unveiling 
in 2007, it has been increasing its market share, running on 68.1\% of 
smartphones sold in the second quarter of 2012 according to a report by 
the International Data Corporation. 
\cite{www.idc.com/getdoc.jsp?containerId=prUS23638712}

Unfortunately, with its growing popularity, the platform became a frequent
target of increasingly sophisticated malware, masquerading as legitimate
software, while leaking sensitive data about users. More complex
malicious applications even try to hide their activity by exploiting 
security holes of the underlying operating system to bypass the 
protection mechanisms of the platform.

Researchers have been coming up with different approaches to solving
this problem, mostly focusing on porting well-established methods from
the desktop environment to resource-limited devices running Android and
other competing mobile operating systems. These methods range from 
static analysis of the executable code, all the way to enforcing sandboxing 
by virtualization. 

One such approach is shown in TaintDroid \cite{www.appanalysis.org}, 
a project developed by a group of researchers from The Pennsylvania State
University, Duke University and Intel Labs. They point out that the
access control in Android is rather coarse-grained, with all-or-nothing
policy. This means that once an application is given access to a resource,
it can do whatever it wants with it, and doesn't need any further consent 
from the user.

TaintDroid modifies several core parts of the Android platform, such as 
the Dalvik VM, the Android shared library, and even the file-system, 
adding support for runtime labelling of sensitive data like the phone number, 
the contact list or GPS location, and tracing the flow of such data through 
the system. By checking the labels of data that are leaving the system, e.g. 
via the network connection, TaintDroid can warn the users about the 
possibility of their data being misused. It is therefore an analytical tool 
providing insight into the behaviour of third-party applications, giving the 
users a better picture of what happens with the data they entrust to their 
applications.

Following the work conducted on TaintDroid, the outcome of this project 
will be a tool with similar goals, but achieving them in a different 
manner. TaintDroid integrates into the lower levels of the operating 
system, altering Dalvik's memory management and instructions to store and
propagate the tags transparently to the applications running on top of 
it. However, similar result can be accomplished by extracting the 
executable code from the application's package and instrumenting it to 
carry out the information-flow analysis itself, without any modification 
to the platform needed, which is what this project will try to attain.

Despite being intended mostly for use by professionals, the configuration 
of monitored privacy policies should be intuitive enough even for users 
without deep understanding of taint-based analysis. Typical user will:
\begin{itemize}
\item{connect their Android device to the computer}
\item{choose an installed application that should be instrumented}
\item{select data sources and output channels (sinks) to be monitored}
\item{wait for the application to get instrumented, repackaged and sent
      back to the device}
\item{run the application and wait for notifications about privacy policy
      violations}
\end{itemize}

Limitations and advantages of both solutions will be thoroughly 
compared in the evaluation section of the dissertation. Obviously, 
the low-level method makes it possible to trace the tags throughout 
the system by patching the IPC kernel module, or storing them within 
attributes of files. This can't be done by per-application bytecode 
instrumentation, but the fact that each application is processed before 
it is loaded back into the device and executed leaves room for static 
analysis of the code, perhaps even alteration of its behaviour. 

\section*{Resources Required}

Development will require a computer with the Android SDK installed. Most 
of the work will be done on my personal computer, but testing on a large 
sample of applications will need to be executed on a PWF machine. 

Large collection of infected applications have been obtained from the
Android Malware Genome Project \cite{www.malgenomeproject.org}. 
Sufficient disc allocation of 3GB will be needed on the PWF to store
a snapshot of the repository. 

An Android smartphone will be supplied by the Department to test 
the project on. In case of problems, the Android emulator can be used 
instead.

\section*{Starting Point}

My previous experience includes a UROP internship at the Computer Lab
in the summer of 2011. Students worked on security-related projects on
the Android platform, an application for encrypted text-messaging in my
case.

During my other internship in the summer of 2012, I worked on Java PathFinder,
a software-verification tool for JVM. My plugin verified correct usage of 
physical units in scientific computation by runtime assignment of attributes 
with unit information to numerical values in the memory, and their propagation 
during arithmetic operations, which is a form of flow tracing. 

In this project I hope to combine my prior skills and apply them in a 
slightly different environment of the Dalvik VM and Android framework,
while learning more about the possibilities of static and dynamic analysis
of bytecode.

\section*{Substance and Structure of the Project}

The main outcome of this project will be a desktop application written 
in Java, capable of instrumenting given Dalvik executables, known as DEX
files, according to options specified via command-line arguments or 
graphical user interface.

%It will use the ASMDEX \cite{asm.ow2.org/asmdex-index.html} library to 
%parse, modify and reconstruct Dalvik bytecode. 

Data sources and sinks will be specified as an XML file containing a list
of classes and/or methods inside the Android library, accessing which
should trigger the tagging mechanism. The same will apply to so-called 
sanitizers, methods that remove any present tags, for example the hashing 
functions. Specifications of commonly used sources, sinks and sanitizers 
will be part of the distribution.

The application will also be able to extract executable code from 
applications on a connected device by executing tools from the Android SDK
and calling apktool \cite{code.google.com/p/android-apktool}. After the 
instumentation, the modified application will be repackaged and uploaded back 
to the device. Since all packages need to be signed and there's no access to 
the original key, packages will be signed by a key of user's choice.

Essential part of the project will form the development of a dependable code 
instrumentation, which will reliably identify the sources and sinks and
propagate the tags throughout the application. This requires detailed
analysis of the effects of each instruction of the Dalvik VM, and 
thorough testing. Special attention will need to be given to correct 
instrumentation of the exception mechanism, which will require static 
analysis of the location of exception-throwing instructions and 
corresponding try/catch blocks, utilising knowledge from the Optimising
Compilers course.

Typical overhead of dynamic data-flow analysis by instruction-level 
varies between 3 and 35 times of the original speed. While there is
very limited room for making the instrumentation itself more efficient,
time can easily be invested into static analysis of the code which will
identify the parts of the code that need to be instrumented, i.e. the 
possible paths between sources and sinks. 

The development process will follow the philosophy of Test Driven 
Development. Thus a significant amount of time will be spent on building 
a robust set of unit tests to ensure high quality of code. JUnit will be 
used to test the internal of the instrumenting application. A set of 
shell scripts will be created to automatically try to execute a collection
of tailored snippets of code on an actual Dalvik virtual machine, 
comparing the output of the original and the instrumented version to ensure
that the instrumentation doesn't affect the behaviour.

\subsubsection*{Implicit-flow analysis}

TaintDroid focuses strictly on tracing the explicit flows of information, 
by propagating the tags when data-handling CPU instructions are used. 
But information can be leaked via implicit flows (branching instructions) 
as well. Consider the following example:

\begin{verbatim}
int sensitiveData = getSensitiveData(); // tagged variable
int leakedData = 0; // tag-free variable

while (sensitiveData--)
    leakedData++;

output(leakedData); // leakedData still not tagged
\end{verbatim}

In this case, \verb|leakedData| has not been tagged, because there is 
no explicit information flow from \verb|sensitiveData| into it. Instead, 
\verb|sensitiveData| effects the control flow of the program, leaking
the information into \verb|leakedData| implicitly. 

Leakage via implicit flow is best identified by static analysis of the 
source code of the program, often used to analyse scripting languages. 
Since the source code is not available for third-party applications on 
Android, it needs to be analysed dynamically on the instruction level.
Downside of this solution is that the propagation rules must be
rather conservative, leading to false positives. This is the reason why
TaintDroid developers decided not to include it into their system-wide
solution. Since this project will instrument applications separately, 
the user will be given the choice of instrumentation including or 
excluding implicit-flow analysis.

\subsection*{Extensions}

Depending on the amount of time necessary to finish the core of the project,
extra effort will be put into extending the list of supported features. Each 
of the following extensions can be implemented separately and they are 
sorted according to the added benefit to the users in descending order.

\subsubsection*{Causality analysis}

While TaintDroid quite reliably identifies privacy policy violations,
it fails to provide the user's action which caused it. The user 
might therefore have trouble distinguishing whether the violation 
happened in a background-running thread or as a result of interaction
with the UI. By instrumenting the message loop of Android Activity class
(equivalent of a window), this information could be provided.

\subsubsection*{Reflection}

One major limitation of analysis by bytecode instrumentation is that it 
cannot easily deal with reflection or dynamically loaded code. The core
project will simply warn the user that these are present in the processed
code, but a possible extension could further explore methods of dealing 
with such calls.

\subsubsection*{FastPath optimization}

The "A Low-Overhead Practical Information Flow Tracking System for 
Detecting Security Attacks" paper, which studied taint-based flow tracing 
in the context of x86 server applications suggests a form of dynamic 
optimization called FastPath. It includes both the original and 
instrumented version of each method in the resulting executable, and
dynamically decides which will be called based on the presence of non-empty 
tags in its arguments. Authors of the paper argued that only 2\% of typical 
function calls were tagged, which is why this optimisation had such  
impact on performance. Whether this is true in the context of Android mobile
applications as well is not clear. Before implementing FastPath, a short 
study of the number of unlabelled method calls should be conducted.

\section*{Success Criterion}

For the project to be deemed a success the following items must be
successfully completed.

\begin{enumerate}

\item Correct way of instrumenting the code needs to be designed and shown
       to propagate taint correctly, with extra attention paid to correct
       exception-handling.

\item Method of source/sink specification has to be designed.

\item Instrumenting application and accompanying repackaging shell scripts
       must be implemented.

\item Details of what output the system should generate and how it
       should be controlled by the user must be specified.

\item Capabilities of the information-flow analysis must be demonstrated
       on examples of real applications.

\item Performance should be compared to the original application and to
       TaintDroid.

\item The dissertation must be planned and written.

\end{enumerate}

\section*{Plan of work}

\begin{itemize}
	\item{\textbf{Fortnight 1:} Instrumenting application set-up; 
	      application-extraction and repackaging scripts; DEX processing, 
	      copying DEX content into a new file}
	\item{\textbf{Fortnight 2:} Instrumentation of trivial instructions;
	      specification and identification of sources and sinks}
	\item{\textbf{Fortnight 3:} Static analysis and instrumentation of 
	      exceptions; time for testing}
	\item{\textbf{Fortnight 4:} Implicit-flow instrumentation; assessment 
	      of its impact}
	\item{\textbf{Fortnight 5:} Performance optimisations}
	\item{\textbf{Fortnight 6:} Causality analysis}
	\item{\textbf{Fortnight 7:} Graphical user interface}
	\item{\textbf{Fortnight 8:} Large-sample testing and evaluation}
	\item{\textbf{Rest:} Dissertation}
\end{itemize}

\printbibliography
\end{document}
